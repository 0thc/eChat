<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width">

	<script src="https://cdn.jsdelivr.net/npm/emojione@4.0.0/lib/js/emojione.min.js"></script>
	<script src="https://cdn.jsdelivr.net/gh/amark/gun@manhattan/examples/jquery.js"></script>
	<script src="https://cdn.jsdelivr.net/gh/amark/gun@manhattan/gun.js"></script>
	<script src="https://cdn.jsdelivr.net/gh/amark/gun@manhattan/sea.js"></script>
	<script src="https://cdn.jsdelivr.net/gh/amark/gun@manhattan/axe.js"></script>
	<script> // main init!
	var app = {
		view: $, // replace with not jquery!
		data: GUN(), // peer-to-peer database!
		key: '#foo' // end-to-end encryption key!
	};
	</script>

</head>
<body>

<div id="login">
	<form id="sign" onsubmit="app.login(event)">
	  <input id="alias" placeholder="username">
	  <input id="pass" type="password" placeholder="passphrase">
	  <input id="in" type="submit" value="sign in">
	  <input id="up" type="button" value="sign up" onclick="app.register()">
	</form>
	<script>
	app.login = function(eve){
		if(app.error(eve)){ return }
	  app.data.user().auth(
	  	app.view('#alias').val(),
	  	app.view('#pass').val(),
	  	app.error
	  );
	};

	app.register = function(eve){
	  app.data.user().create(
	  	app.view('#alias').val(),
	  	app.view('#pass').val(),
	  	app.login
	  );
	};

	app.data.on('auth', function(eve){
	  app.view('#sign').hide(); // hide login form upon logging in.
	});
	</script>
</div>

<div id="chat">
	<ul id='chats'>
		<li class="model message">
			<span class="what"></span>
			<span class="when" style="display: none"></span>
		</li>
	</ul>
	<script>
	var match = { // lexical queries are kind of like a limited RegEx or Glob.
		'.': { // property selector
			'>': (new Date(+new Date - (1 * 1000 * 60 * 60 * 3))).toISOString() // find any indexed property larger ~3 hours ago
		},
		'-': 1 // filter in reverse
	};
	app.data.get('chat').map().once(async function(data, id){
		var message = { // transform the data
			who: app.data.user(data), // a user might lie who they are! So let the user system detect whose data it is.
			what: await SEA.decrypt(data.what, app.key)+"", // force decrypt as text.
			when: GUN.state.is(data, 'what') // get the internal timestamp for the what property.
		};

		if(!message.what){ return }
		message.what = emojione.shortnameToUnicode(message.what);
		//if(disagreesWithMyPolitics(app.view('#tribe').val()).detect(message.what)){
		//	return app.data.user().get('ban').set(message.who); // show to the world how holy I am.
		//}

		var sort = app.sort(message.sort = message.when||0, app.view('#chats').find('li').last()); // might not work.
		message.when = new Date(message.when).toDateString()+', '+new Date(message.when).toLocaleTimeString();
		
		app.render(message, '.message',  sort, 'insertAfter', id);
	  app.view('#send').get(0).scrollIntoView({behavior: 'smooth'}); //window.scroll(0, ul.offsetHeight);
	  app.profiles(message.who, id); // OPTIONAL!
		
	  var beep = new SpeechSynthesisUtterance(); // make new notification sound.
	  beep.text = "new"; beep.rate = 10; beep.pitch = 2;
	  window.speechSynthesis.speak(beep);
	});

	app.render = async function(data, as, to, how, id){
		id = btoa(id || Math.random()).replace(/\W/ig, ''); // DOM safe.
		as = app.view('#'+id).get(0) || app.view('.model'+as).clone(true) // get or clone
			.removeClass('model').attr('id',id)[how||'appendTo'](to); // clean up.
		Object.keys(data).forEach(function(prop){
			app.view(as).find('.'+prop).text(data[prop]);
		});
		return app.view(as);
	}

	app.profiles = async function(who, id){ // some ugly code, but cool feature!
		if(!who){ return }
		id = btoa(id).replace(/\W/ig, ''); // DOM safe.
		var pub = btoa(await who.get('pub').then()).replace(/\W/ig, ''); // DOM safe.
		app.view('#'+id).addClass('profile-'+pub);
		var css = app.view('#profile-'+pub).get(0);
		if(css){ return }
		css = document.createElement('style');
		css.id = 'profile-'+pub;
		css.type = 'text/css';
		app.view('head').get(0).appendChild(css);
		who.get('face').on(function(b64){
			css.innerHTML = '.profile-'+pub+' { list-style-image: url("'+b64+'"); list-style-position: inside; }';
		});
	}

	app.sort = function(num, li, by){ // I don't think this works.
		return parseFloat(num) >= parseFloat($(li).find(by||'.sort').text() || -Infinity) ? li : sort(num, li.prev())
	}
	</script>
</div>

<div id="send">
	<form id='write' onsubmit="app.send(event)">
	  <input id='message' placeholder="write message...">
	  <input type='submit' value='send'>
	</form>
	<script>
	app.send = async function(eve){
	  if(app.error(eve)){ return }
	  if(!app.data.user().is){
	  	return app.error({err: "Not signed in!"});
	  }
	  var text = app.view('#message').val();
	  if(!text){ return app.error({err: "No message."}) }
	  app.view('#message').val(""); // clear out input for next message.
	  
	  var secret = await SEA.encrypt(text, app.key); // encrypt it so only people with the key can read it (anyone who has the link).
	  if(!secret){ return app.error({err: SEA.err}) }

	  var message = app.data.user().get('all').set({what: secret}); // save their message!
		var index = (new Date).toISOString();
		app.data.get('chat').get(index).put(message); // index message by time in chat!

		
	  return;

		var hash = await SEA.work(secret, null, null, {name: "SHA-256"});
		var index = (new Date).toISOString() + ('#'+hash); // index by time with hash.

		var ref = app.data.get('#chat').get(index).put(secret); // SEA, not GUN, will treat # records as immutable.
	  app.data.user().get('all').set(ref); // index all messages they send!
	}
	</script>
</div>

<div id="profile">
	<p>Set public profile: <img id="face" style="height: 2.5em; vertical-align: middle;"> <input id="upload" type="file" multiple></p>
	<script src="https://cdn.jsdelivr.net/gh/amark/gun@manhattan/lib/upload.js"></script>
	<script>
	app.view('html, #upload').upload(function resize(eve, up){
	  if(!app.data.user().is){
	  	app.error({err: "Not signed in!"});
	  	return;
	  }
	  if(up){ return up.shrink(eve, resize, 128) }
	  var b64 = (eve.base64 || ((eve.event || eve).target || eve).result || eve);
		app.view('#face').get(0).src = b64;
	  app.data.user().get('face').put(b64);
	});
	</script>

	<button id="own" onclick="app.own()">Show only my messages.</button>
	<ul id='mine'></ul>
	<script>
	app.own = function(){
	  if(!app.data.user().is){
	  	return app.error({err: "Not signed in!"});
	  }
		app.data.user().get('all').map().once(async function(data, id){
			var message = {
				what: await SEA.decrypt(data.what, app.key)
			}
			app.render(message, '.message', '#mine', 0, 'my-'+id);
			app.profiles(app.data.user(data), 'my-'+id); // OPTIONAL!
		});
	}
	</script>
</div>

<span id="error">
	<span id="err"></span>
	<script>
	app.error = function(eve){
		app.view('#err').text('').hide();
		if(!eve){ return }
		if(eve.preventDefault){
			eve.preventDefault();
			return;
		}
		if(!eve.err){ return }
		app.view('#err').text(eve.err).show();
		return true;
	}
	</script>
</span>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/emojione@4.0.0/extras/css/emojione.min.css"/>
<style>
.model {display: none;}
#error { position: fixed; top: 0; width: 100%; text-align: center; background: white; }
</style>
</body>
</html>


















